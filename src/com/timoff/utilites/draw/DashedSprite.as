package com.timoff.utilites.draw {		import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Point;	import flash.display.CapsStyle;		public class DashedSprite extends Sprite {				var lengthsArray:Array = new Array();		var lineColor:uint = 0;		var lineWeight:Number = 1;		var lineAlpha:Number = 1;		var curX:Number = 0;		var curY:Number = 0;		var remainingDist:Number = 0;		var curIndex:int;		var arraySum:Number = 0;		var startIndex:int = 0;		var fill:Shape = new Shape();		var stroke:Shape = new Shape();				public function DashedSprite(weight = 0, color = 0, lengthsArray:Array = null){						if (lengthsArray != null){	// if lengths array was specified, use it				this.lengthsArray = lengthsArray;			} else {	// if unspecified, use a default 5-5 line				this.lengthsArray = [5,5];			}			if (this.lengthsArray.length % 2 != 0){	// if array has more dashes than gaps (i.e. an odd number of values), add a 5 gap to the end				lengthsArray.push(5);			}						for (var i in lengthsArray){				arraySum += lengthsArray[i];			}			lineWeight = weight;			lineColor = color;						stroke.graphics.lineStyle(lineWeight,lineColor,lineAlpha,false,"none",CapsStyle.NONE);			addChild(fill);			addChild(stroke);		}				// basic moveTo method		public function moveTo(x,y):void{			stroke.graphics.moveTo(x,y);	// move to specified x and y			fill.graphics.moveTo(x,y);			curX = x;			curY = y;			// reset remainingDist and startIndex - if we are moving away from last line segment, the next one will start at the beginning of the dash-gap sequence			remainingDist = 0;			startIndex = 0;		}        public function drawRect(width:Number, height:Number):void        {            clear();            lineTo(width,0);            lineTo(width,height);            lineTo(0,height);            lineTo(0,0);            //lineTo(height,0);            //lineTo(0,0);            //stroke.graphics.endFill();            //fill.graphics.endFill();            return;        }		// lineTo method		public function lineTo(x,y):void{			var slope:Number = (y - curY)/(x - curX);	// get slope of segment to be drawn			var startX:Number = curX;			var startY:Number = curY;			var xDir:int = (x < startX) ? -1 : 1;			var yDir:int = (y < startY) ? -1 : 1;			outerLoop : while (Math.abs(startX-curX) < Math.abs(startX-x) || Math.abs(startY-curY) < Math.abs(startY-y)){				// loop through the array to draw the appropriate dash or gap, beginning with startIndex (either 0 or determined by the end of the last lineTo)				for (var i:int = startIndex; i < lengthsArray.length; i++){						var dist:Number = (remainingDist == 0) ? lengthsArray[i] : remainingDist;	// distance to draw is either the dash/gap length from the array or remainingDist left over from the last lineTo if there is any						var xInc:Number = getCoords(dist,slope).x * xDir;						var yInc:Number = getCoords(dist,slope).y * yDir;						if (Math.abs(startX-curX) + Math.abs(xInc) < Math.abs(startX-x) || Math.abs(startY-curY) + Math.abs(yInc) < Math.abs(startY-y)){							if (i % 2 == 0){	// if even index in the array, it is a dash, hence lineTo								stroke.graphics.lineTo(curX + xInc,curY + yInc);							} else {	// if odd, it's a gap, so moveTo								stroke.graphics.moveTo(curX + xInc,curY + yInc);							}							curX += xInc;							curY += yInc;							curIndex = i;	// store the current dash or gap (array index)							startIndex = 0;							remainingDist = 0;						} else {							remainingDist = getDistance(curX,curY,x,y);	// get the distance between the end of the last dash or gap and the destination x/y							curIndex = i;	// store the current index							break outerLoop;	// break out of the while loop						}				}			}						startIndex = curIndex;			if (remainingDist != 0){				if (curIndex % 2 == 0){					stroke.graphics.lineTo(x,y);				} else {					stroke.graphics.moveTo(x,y);				}				remainingDist = lengthsArray[curIndex] - remainingDist;			} else {				if (startIndex == lengthsArray.length - 1){					startIndex = 0;				} else {					startIndex++;				}			}			curX = x;			curY = y;			fill.graphics.lineTo(x,y);		}				// returns a point with the vertical and horizontal components of a diagonal given the distance and slope		private function getCoords(distance,slope):Point {			var angle:Number = Math.atan(slope);	// get the angle from the slope			var vertical:Number = Math.abs(Math.sin(angle)*distance);	// vertical from sine of angle and length of hypotenuse - using absolute value here and applying negative as needed in lineTo, because this number doesn't always turn out to be negative or positive exactly when I want it to (haven't thought through the math enough yet to figure out why)			var horizontal:Number = Math.abs(Math.cos(angle)*distance);	// horizontal from cosine			return new Point(horizontal,vertical);	// return the point					}				// basic Euclidean distance		private function getDistance(startX,startY,endX,endY):Number{			var distance:Number = Math.sqrt(Math.pow((endX-startX),2) + Math.pow((endY-startY),2));			return distance;		}				// clear everything and reset the lineStyle		public function clear():void{			stroke.graphics.clear();			stroke.graphics.lineStyle(lineWeight,lineColor,lineAlpha,false,"none",CapsStyle.NONE);			fill.graphics.clear();			moveTo(0,0);		}				// set lineStyle with specified weight, color, and alpha		public function lineStyle(w=0,c=0,a=1):void{			lineWeight = w;			lineColor = c;			lineAlpha = a;			stroke.graphics.lineStyle(lineWeight,lineColor,lineAlpha,false,"none",CapsStyle.NONE);		}				// basic beginFill		public function beginFill(c,a=1):void{			fill.graphics.beginFill(c,a);		}		// basic endFill		public function endFill():void{			fill.graphics.endFill();		}	}}